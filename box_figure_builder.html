<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Box Figure Builder</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/pptxgenjs@3.10.0/dist/pptxgen.bundle.js"></script>
  <style>
    :root {
      color-scheme: light;
    }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    textarea {
      resize: vertical;
    }
    .input {
      width: 100%;
      border: 1px solid #cbd5f5;
      border-radius: 0.375rem;
      padding: 0.1rem 0.3rem;
      font-size: 0.75rem;
      background-color: #fff;
      height: 1.4rem;
    }
    textarea.input {
      height: auto;
      min-height: 2.2rem;
    }
    .btn {
      padding: 0.25rem 0.6rem;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      font-weight: 600;
      border: 1px solid #cbd5f5;
      background-color: #fff;
      color: #1f2937;
      transition: background-color 0.15s ease, border-color 0.15s ease;
    }
    .btn:hover {
      background-color: #f8fafc;
    }
    .btn-primary {
      background-color: #0f172a;
      border-color: #0f172a;
      color: #fff;
    }
    .btn-primary:hover {
      background-color: #1e293b;
    }
    .btn-danger {
      background-color: #fff1f2;
      border-color: #fecdd3;
      color: #be123c;
    }
    .btn-danger:hover {
      background-color: #ffe4e6;
    }
    .section {
      border: 1px solid #e2e8f0;
      border-radius: 0.75rem;
      padding: 0.45rem;
      background-color: #fff;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
    }
    .label {
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #64748b;
    }
    details.section summary {
      cursor: pointer;
      list-style: none;
    }
    details.section summary::-webkit-details-marker {
      display: none;
    }
    .section-summary {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      font-weight: 600;
      color: #0f172a;
    }
    .section-summary span {
      font-size: 0.9rem;
    }
    .summary-caret {
      width: 0.6rem;
      height: 0.6rem;
      border-right: 2px solid #94a3b8;
      border-bottom: 2px solid #94a3b8;
      transform: rotate(-45deg);
      transition: transform 0.2s ease;
    }
    details[open] .summary-caret {
      transform: rotate(45deg);
    }
    .sidebar-grid {
      display: grid;
      gap: 0.4rem 0.6rem;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
    .sidebar-actions {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.5rem;
    }
    .form-rows {
      display: grid;
      gap: 0.35rem;
    }
    .form-row {
      display: grid;
      grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.2fr);
      gap: 0.35rem;
      align-items: center;
    }
    .form-row--double {
      grid-template-columns: minmax(0, 0.75fr) minmax(0, 1fr) minmax(0, 0.75fr) minmax(0, 1fr);
    }
    .form-row--start {
      align-items: start;
    }
    .text-size-control {
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) auto;
      gap: 0.3rem;
      align-items: center;
    }
    .text-size-btn {
      height: 1.4rem;
      padding: 0.1rem 0.4rem;
      line-height: 1;
    }
    .text-size-input {
      text-align: center;
    }
    .button-row {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.3rem;
    }
    .item-card {
      border: 1px solid #e2e8f0;
      border-radius: 0.75rem;
      padding: 0.35rem;
      background-color: #f8fafc;
    }
    .box-card {
      border: 1px solid #e2e8f0;
      border-radius: 0.6rem;
      padding: 0.35rem;
      background-color: #fff;
    }
    .item-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .legend-chip {
      font-weight: 600;
      border-radius: 0.5rem;
    }
  </style>
</head>
<body class="min-h-screen bg-slate-100">
  <div class="min-h-screen flex flex-col md:flex-row">
    <aside class="w-full md:w-[360px] bg-white border-b md:border-b-0 md:border-r border-slate-200 overflow-y-auto p-4 space-y-4" id="sidebar">
      <!-- Sidebar content -->
    </aside>
    <main class="flex-1 p-4">
      <div class="flex items-center justify-between mb-3">
        <div>
          <h1 class="text-xl font-semibold text-slate-800">Box Figure Builder</h1>
          <p class="text-sm text-slate-500">Build rows of variable-sized boxes with a legend-driven color system.</p>
        </div>
        <button class="btn" id="clearStorageBtn">Clear Local Draft</button>
      </div>
      <div class="border border-slate-200 rounded-lg bg-white shadow-sm">
        <div class="p-3 border-b border-slate-200 text-sm text-slate-600">SVG Canvas (scrolls vertically if needed)</div>
        <div id="canvasContainer" class="overflow-auto" style="height: 420px;">
          <svg id="figureSvg" width="100%" height="420" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
      </div>
    </main>
  </div>

  <script>
    const STORAGE_KEY = "box_figure_builder_state";

    const defaultPalette = [
      "#2f5eb5",
      "#4aa3df",
      "#45b3d6",
      "#8a6ac4",
      "#c25a91",
      "#7b5bb3"
    ];

    const defaultState = {
      settings: {
        spacingPx: 14,
        rowGapPx: 24,
        paddingPx: 24,
        textSizePx: 11,
        legendTextSizePx: 12,
        heightFactor: 1,
        canvasWidthPx: 960,
        canvasHeightPx: 420,
        heightScalePxPerUnit: 12
      },
      legendItems: [
        { key: "Phase 9", label: "Phase 9", colorHex: "#2f5eb5" },
        { key: "Phase 8", label: "Phase 8", colorHex: "#4aa3df" },
        { key: "Phase 6", label: "Phase 6", colorHex: "#45b3d6" },
        { key: "Phase 5", label: "Phase 5", colorHex: "#8a6ac4" },
        { key: "Phase 4", label: "Phase 4", colorHex: "#c25a91" },
        { key: "Phase 3", label: "Phase 3", colorHex: "#7b5bb3" }
      ],
      rows: [
        {
          name: "Row 1",
          boxes: [
            { width_value: 18, height_value: 2.6, legend_key: "Phase 9", text: "Weeks 5.9\nMMR 5.1", textSizePx: 11 },
            { width_value: 26, height_value: 1.5, legend_key: "Phase 8", text: "Weeks 5.9\nMMR 9.0", textSizePx: 11 },
            { width_value: 22, height_value: 1.8, legend_key: "Phase 6", text: "Weeks 3.0\nMMR 9.5", textSizePx: 11 },
            { width_value: 14, height_value: 2.2, legend_key: "Phase 5", text: "Weeks 9.5\nMMR 8.0", textSizePx: 11 },
            { width_value: 5, height_value: 2.2, legend_key: "Phase 4", text: "Weeks\n0.1\nMMR 8", textSizePx: 11 },
            { width_value: 9, height_value: 5.2, legend_key: "Phase 3", text: "Weeks 9.8\nMMR 1.0", textSizePx: 11 }
          ]
        }
      ]
    };

    let state = normalizeState(loadState() || structuredClone(defaultState));
    let saveTimeout = null;

    function debounceSave() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }, 400);
    }

    function loadState() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      try {
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function normalizeState(rawState) {
      const next = structuredClone(defaultState);
      if (!rawState) return next;
      next.settings = { ...defaultState.settings, ...(rawState.settings || {}) };
      next.settings.textSizePx = Number.isFinite(next.settings.textSizePx) ? next.settings.textSizePx : 11;
      next.settings.legendTextSizePx = Number.isFinite(next.settings.legendTextSizePx) ? next.settings.legendTextSizePx : 12;

      const legendItems = Array.isArray(rawState.legendItems) ? rawState.legendItems : [];
      next.legendItems = legendItems.map((item, index) => {
        const key = String(item?.key ?? `Legend ${index + 1}`);
        const label = String(item?.label ?? key);
        const normalized = normalizeHex(String(item?.colorHex ?? ""));
        return {
          key,
          label,
          colorHex: normalized || defaultPalette[index % defaultPalette.length]
        };
      });

      const rows = Array.isArray(rawState.rows) ? rawState.rows : [];
      next.rows = rows.map((row, rowIndex) => {
        const name = String(row?.name ?? `Row ${rowIndex + 1}`);
        const boxes = Array.isArray(row?.boxes) ? row.boxes : [];
        const normalizedBoxes = boxes.map((box) => ({
          width_value: Number(box?.width_value ?? 0),
          height_value: Number(box?.height_value ?? 0),
          legend_key: String(box?.legend_key ?? ""),
          text: String(box?.text ?? ""),
          textSizePx: Number.isFinite(box?.textSizePx) ? Number(box.textSizePx) : null
        }));
        return { name, boxes: normalizedBoxes };
      });

      next.rows.forEach((row) => row.boxes.forEach((box) => ensureLegendKey(box, next.legendItems)));
      return next;
    }

    function ensureLegendKey(box, legendItems = state.legendItems) {
      const keys = legendItems.map((item) => item.key);
      if (!keys.includes(box.legend_key)) {
        box.legend_key = keys[0] || "";
      }
    }

    function renderSidebar() {
      const sidebar = document.getElementById("sidebar");
      const legendOptions = state.legendItems
        .map((item) => {
          const label = item.label || item.key;
          const textColor = autoTextColor(item.colorHex);
          return `<option value="${escapeHtml(item.key)}" style="background-color: ${item.colorHex}; color: ${textColor};">${escapeHtml(label)} (${escapeHtml(item.colorHex)})</option>`;
        })
        .join("");

      sidebar.innerHTML = `
        <details class="section space-y-3" open>
          <summary class="section-summary">
            <span>Rows & Boxes</span>
            <span class="summary-caret"></span>
          </summary>
          <div class="space-y-3">
            ${state.rows.map((row, rowIndex) => `
              <details class="item-card space-y-2" open>
                <summary class="section-summary">
                  <span>${escapeHtml(row.name || `Row ${rowIndex + 1}`)}</span>
                  <span class="summary-caret"></span>
                </summary>
                <div class="space-y-2">
                  <div class="form-row">
                    <span class="label">Row Name</span>
                    <input type="text" class="input" data-action="row-name" data-row="${rowIndex}" value="${escapeHtml(row.name)}">
                  </div>
                  <div class="button-row">
                    <button class="btn" data-action="row-up" data-row="${rowIndex}">Move Up</button>
                    <button class="btn" data-action="row-down" data-row="${rowIndex}">Move Down</button>
                    <button class="btn btn-danger" data-action="row-delete" data-row="${rowIndex}">Delete Row</button>
                  </div>
                </div>
                <div class="space-y-2">
                  ${row.boxes.map((box, boxIndex) => {
                    const legendHex = legendColor(box.legend_key);
                    const legendText = autoTextColor(legendHex);
                    return `
                    <div class="box-card space-y-2">
                      <div class="item-card-header">
                        <span class="text-xs font-semibold text-slate-500">Box ${boxIndex + 1}</span>
                        <div class="button-row">
                          <button class="btn" data-action="box-left" data-row="${rowIndex}" data-box="${boxIndex}">←</button>
                          <button class="btn" data-action="box-right" data-row="${rowIndex}" data-box="${boxIndex}">→</button>
                          <button class="btn" data-action="box-duplicate" data-row="${rowIndex}" data-box="${boxIndex}">Duplicate</button>
                          <button class="btn btn-danger" data-action="box-delete" data-row="${rowIndex}" data-box="${boxIndex}">Delete</button>
                        </div>
                      </div>
                      <div class="form-rows">
                        <div class="form-row">
                          <span class="label">Width</span>
                          <input type="number" step="0.1" class="input" data-action="box-width" data-row="${rowIndex}" data-box="${boxIndex}" value="${box.width_value}">
                        </div>
                        <div class="form-row">
                          <span class="label">Height</span>
                          <input type="number" step="0.1" class="input" data-action="box-height" data-row="${rowIndex}" data-box="${boxIndex}" value="${box.height_value}">
                        </div>
                        <div class="form-row">
                          <span class="label">Text</span>
                          <textarea class="input" rows="2" data-action="box-text" data-row="${rowIndex}" data-box="${boxIndex}">${escapeHtml(box.text)}</textarea>
                        </div>
                        <div class="form-row">
                          <span class="label">Color</span>
                          <select class="input" data-action="box-legend" data-row="${rowIndex}" data-box="${boxIndex}" style="background-color: ${legendHex}; color: ${legendText};">
                            ${legendOptions}
                          </select>
                        </div>
                        <div class="form-row">
                          <span class="label">Text Size</span>
                          <div class="text-size-control">
                            <button class="btn text-size-btn" data-action="box-text-size-step" data-step="-1" data-row="${rowIndex}" data-box="${boxIndex}">−</button>
                            <input type="number" min="1" step="1" class="input text-size-input" data-action="box-text-size" data-row="${rowIndex}" data-box="${boxIndex}" value="${box.textSizePx ?? state.settings.textSizePx}">
                            <button class="btn text-size-btn" data-action="box-text-size-step" data-step="1" data-row="${rowIndex}" data-box="${boxIndex}">+</button>
                          </div>
                        </div>
                      </div>
                    </div>
                  `;
                  }).join("")}
                </div>
                <button class="btn w-full" data-action="box-add" data-row="${rowIndex}">Add Box</button>
              </details>
            `).join("")}
          </div>
          <button class="btn w-full" id="addRowBtn">Add Row</button>
        </details>

        <details class="section space-y-3" open>
          <summary class="section-summary">
            <span>Legend Editor</span>
            <span class="summary-caret"></span>
          </summary>
          <div class="flex items-center justify-between">
            <span class="text-xs text-slate-500">Legend categories control box colors.</span>
            <button class="btn" id="addLegendBtn">Add Legend Item</button>
          </div>
          <div class="form-row">
            <span class="label">Legend Text Size (px)</span>
            <input type="number" min="1" step="1" class="input" id="legendTextSizePx" value="${state.settings.legendTextSizePx ?? 12}">
          </div>
          <div class="space-y-2">
            ${state.legendItems.map((item, idx) => `
              <div class="item-card space-y-2">
                <div class="item-card-header">
                  <span class="text-xs font-semibold text-slate-500">${escapeHtml(item.label || item.key || `Legend ${idx + 1}`)}</span>
                  <button class="btn btn-danger" data-action="remove-legend" data-index="${idx}">Remove</button>
                </div>
                <div class="form-rows">
                  <div class="form-row">
                    <span class="label">Label</span>
                    <input type="text" class="input" data-action="legend-label" data-index="${idx}" value="${escapeHtml(item.label)}">
                  </div>
                  <div class="form-row">
                    <span class="label">Color</span>
                    <input type="color" class="input h-8 p-1" data-action="legend-color" data-index="${idx}" value="${escapeHtml(item.colorHex)}">
                  </div>
                </div>
              </div>
            `).join("")}
          </div>
        </details>

        <details class="section space-y-3">
          <summary class="section-summary">
            <span>Global Settings</span>
            <span class="summary-caret"></span>
          </summary>
          <div class="form-rows">
            <div class="form-row">
              <span class="label">Spacing (px)</span>
              <input type="number" min="0" step="1" class="input" id="spacingPx" value="${state.settings.spacingPx}">
            </div>
            <div class="form-row">
              <span class="label">Default Text Size (px)</span>
              <input type="number" min="1" step="1" class="input" id="textSizePx" value="${state.settings.textSizePx ?? 11}">
            </div>
            <div class="form-row">
              <span class="label">Canvas Width (px)</span>
              <input type="number" min="200" step="10" class="input" id="canvasWidthPx" value="${state.settings.canvasWidthPx}">
            </div>
            <div class="form-row">
              <span class="label">Row Gap (px)</span>
              <input type="number" min="0" step="1" class="input" id="rowGapPx" value="${state.settings.rowGapPx}">
            </div>
            <div class="form-row">
              <span class="label">Height Factor</span>
              <input type="number" step="0.1" class="input" id="heightFactor" value="${state.settings.heightFactor}">
            </div>
          </div>
          <div class="button-row pt-2">
            <button class="btn" id="loadSampleBtn">Load Sample</button>
          </div>
        </details>

        <details class="section space-y-3">
          <summary class="section-summary">
            <span>Advanced Settings</span>
            <span class="summary-caret"></span>
          </summary>
          <div class="space-y-2">
            <span class="label">Export Controls</span>
            <div class="button-row">
              <button class="btn" id="exportCsvBtn">Export CSV</button>
              <button class="btn" id="exportJsonBtn">Export JSON</button>
              <button class="btn" id="exportSvgBtn">Export SVG</button>
              <button class="btn" id="exportPngBtn">Export PNG</button>
              <button class="btn" id="exportPptxBtn">Export PPTX</button>
            </div>
          </div>
          <div class="space-y-2">
            <span class="label">Import CSV</span>
            <p class="text-[0.7rem] text-slate-500 leading-snug">
              CSV header required: <code class="font-mono">row,box,width,height,legend,text</code>. The row column can be a row name or number.
              Optional metadata lines can appear above the header (start with <code class="font-mono">#</code>) for settings and legend entries.
            </p>
            <input type="file" accept=".csv,text/csv" class="text-xs" id="importCsvFile">
            <textarea class="input" id="pasteCsv" rows="2" placeholder="Paste CSV here..."></textarea>
            <button class="btn w-full" id="importCsvBtn">Import CSV</button>
          </div>
        </details>
      `;

      document.querySelectorAll("select[data-action='box-legend']").forEach((select) => {
        const rowIndex = Number(select.dataset.row);
        const boxIndex = Number(select.dataset.box);
        select.value = state.rows[rowIndex].boxes[boxIndex].legend_key;
        const hex = legendColor(select.value);
        select.style.backgroundColor = hex;
        select.style.color = autoTextColor(hex);
      });

      bindSidebarEvents();
    }

    function bindSidebarEvents() {
      const settingsMap = {
        spacingPx: "spacingPx",
        rowGapPx: "rowGapPx",
        paddingPx: "paddingPx",
        textSizePx: "textSizePx",
        legendTextSizePx: "legendTextSizePx",
        heightFactor: "heightFactor",
        canvasWidthPx: "canvasWidthPx",
        canvasHeightPx: "canvasHeightPx",
        heightScalePxPerUnit: "heightScalePxPerUnit"
      };

      Object.keys(settingsMap).forEach((id) => {
        const input = document.getElementById(id);
        if (!input) return;
        input.addEventListener("input", (event) => {
          const key = settingsMap[id];
          const value = Number(event.target.value);
          if (!Number.isNaN(value)) {
            if (key === "textSizePx" && value <= 0) {
              state.settings[key] = 11;
            } else if (key === "legendTextSizePx" && value <= 0) {
              state.settings[key] = 12;
            } else {
              state.settings[key] = value;
            }
            applyCanvasHeight();
            renderFigure();
            debounceSave();
          }
        });
      });

      document.getElementById("addRowBtn").addEventListener("click", () => {
        state.rows.push({ name: `Row ${state.rows.length + 1}`, boxes: [] });
        renderAll();
        debounceSave();
      });

      document.getElementById("loadSampleBtn").addEventListener("click", () => {
        state = structuredClone(defaultState);
        renderAll();
        debounceSave();
      });

      document.getElementById("exportCsvBtn").addEventListener("click", exportCsv);
      document.getElementById("exportJsonBtn").addEventListener("click", exportJson);
      document.getElementById("exportSvgBtn").addEventListener("click", exportSvg);
      document.getElementById("exportPngBtn").addEventListener("click", exportPng);
      document.getElementById("exportPptxBtn").addEventListener("click", exportPptx);

      document.getElementById("importCsvBtn").addEventListener("click", () => {
        const text = document.getElementById("pasteCsv").value.trim();
        if (text) importCsv(text);
      });

      document.getElementById("importCsvFile").addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (!file) return;
        file.text().then((text) => importCsv(text));
      });

      document.getElementById("addLegendBtn").addEventListener("click", () => {
        const nextColor = defaultPalette[state.legendItems.length % defaultPalette.length];
        state.legendItems.push({ key: `Legend ${state.legendItems.length + 1}`, label: "New Item", colorHex: nextColor });
        renderAll();
        debounceSave();
      });

      document.querySelectorAll("[data-action='remove-legend']").forEach((btn) => {
        btn.addEventListener("click", () => {
          const idx = Number(btn.dataset.index);
          const removed = state.legendItems.splice(idx, 1)[0];
          state.rows.forEach((row) => {
            row.boxes.forEach((box) => {
              if (box.legend_key === removed.key) {
                ensureLegendKey(box);
              }
            });
          });
          renderAll();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='legend-label']").forEach((input) => {
        input.addEventListener("input", () => {
          const idx = Number(input.dataset.index);
          state.legendItems[idx].label = input.value;
          renderFigure();
          debounceSave();
        });
        input.addEventListener("change", () => {
          const idx = Number(input.dataset.index);
          const oldKey = state.legendItems[idx].key;
          const newKey = input.value.trim() || oldKey;
          state.legendItems[idx].key = newKey;
          state.legendItems[idx].label = newKey;
          renderFigure();
          state.rows.forEach((row) => {
            row.boxes.forEach((box) => {
              if (box.legend_key === oldKey) {
                box.legend_key = newKey;
              }
            });
          });
          renderAll();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='legend-color']").forEach((input) => {
        input.addEventListener("input", () => {
          const idx = Number(input.dataset.index);
          state.legendItems[idx].colorHex = input.value;
          renderFigure();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='row-name']").forEach((input) => {
        input.addEventListener("input", () => {
          const rowIndex = Number(input.dataset.row);
          state.rows[rowIndex].name = input.value;
          debounceSave();
        });
        input.addEventListener("change", () => {
          const rowIndex = Number(input.dataset.row);
          const cleaned = input.value.trim();
          if (!cleaned) {
            const fallback = `Row ${rowIndex + 1}`;
            state.rows[rowIndex].name = fallback;
            input.value = fallback;
          }
          renderSidebar();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='row-up']").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rowIndex = Number(btn.dataset.row);
          if (rowIndex === 0) return;
          const [row] = state.rows.splice(rowIndex, 1);
          state.rows.splice(rowIndex - 1, 0, row);
          renderAll();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='row-down']").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rowIndex = Number(btn.dataset.row);
          if (rowIndex === state.rows.length - 1) return;
          const [row] = state.rows.splice(rowIndex, 1);
          state.rows.splice(rowIndex + 1, 0, row);
          renderAll();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='row-delete']").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rowIndex = Number(btn.dataset.row);
          state.rows.splice(rowIndex, 1);
          renderAll();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='box-add']").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rowIndex = Number(btn.dataset.row);
          const legendKey = state.legendItems[0]?.key || "";
          state.rows[rowIndex].boxes.push({
            width_value: 10,
            height_value: 3,
            legend_key: legendKey,
            text: "",
            textSizePx: state.settings.textSizePx
          });
          renderAll();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='box-width']").forEach((input) => {
        input.addEventListener("input", () => {
          const rowIndex = Number(input.dataset.row);
          const boxIndex = Number(input.dataset.box);
          const value = Number(input.value);
          if (!Number.isNaN(value)) {
            state.rows[rowIndex].boxes[boxIndex].width_value = value;
            renderFigure();
            debounceSave();
          }
        });
      });

      document.querySelectorAll("[data-action='box-height']").forEach((input) => {
        input.addEventListener("input", () => {
          const rowIndex = Number(input.dataset.row);
          const boxIndex = Number(input.dataset.box);
          const value = Number(input.value);
          if (!Number.isNaN(value)) {
            state.rows[rowIndex].boxes[boxIndex].height_value = value;
            renderFigure();
            debounceSave();
          }
        });
      });

      document.querySelectorAll("[data-action='box-legend']").forEach((select) => {
        select.addEventListener("change", () => {
          const rowIndex = Number(select.dataset.row);
          const boxIndex = Number(select.dataset.box);
          state.rows[rowIndex].boxes[boxIndex].legend_key = select.value;
          const hex = legendColor(select.value);
          select.style.backgroundColor = hex;
          select.style.color = autoTextColor(hex);
          renderFigure();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='box-text']").forEach((textarea) => {
        textarea.addEventListener("input", () => {
          const rowIndex = Number(textarea.dataset.row);
          const boxIndex = Number(textarea.dataset.box);
          state.rows[rowIndex].boxes[boxIndex].text = textarea.value;
          renderFigure();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='box-text-size']").forEach((input) => {
        input.addEventListener("input", () => {
          const rowIndex = Number(input.dataset.row);
          const boxIndex = Number(input.dataset.box);
          const raw = input.value.trim();
          if (raw === "") {
            state.rows[rowIndex].boxes[boxIndex].textSizePx = null;
            renderFigure();
            debounceSave();
            return;
          }
          const value = Number(raw);
          if (!Number.isNaN(value)) {
            state.rows[rowIndex].boxes[boxIndex].textSizePx = value;
            renderFigure();
            debounceSave();
          }
        });
      });

      document.querySelectorAll("[data-action='box-text-size-step']").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rowIndex = Number(btn.dataset.row);
          const boxIndex = Number(btn.dataset.box);
          const step = Number(btn.dataset.step || 0);
          const box = state.rows[rowIndex].boxes[boxIndex];
          const current = box.textSizePx ?? state.settings.textSizePx ?? 11;
          const nextValue = Math.max(1, current + step);
          box.textSizePx = nextValue;
          const input = document.querySelector(
            `[data-action="box-text-size"][data-row="${rowIndex}"][data-box="${boxIndex}"]`
          );
          if (input) {
            input.value = nextValue;
          }
          renderFigure();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='box-left']").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rowIndex = Number(btn.dataset.row);
          const boxIndex = Number(btn.dataset.box);
          if (boxIndex === 0) return;
          const boxes = state.rows[rowIndex].boxes;
          const [box] = boxes.splice(boxIndex, 1);
          boxes.splice(boxIndex - 1, 0, box);
          renderAll();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='box-right']").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rowIndex = Number(btn.dataset.row);
          const boxIndex = Number(btn.dataset.box);
          const boxes = state.rows[rowIndex].boxes;
          if (boxIndex >= boxes.length - 1) return;
          const [box] = boxes.splice(boxIndex, 1);
          boxes.splice(boxIndex + 1, 0, box);
          renderAll();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='box-duplicate']").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rowIndex = Number(btn.dataset.row);
          const boxIndex = Number(btn.dataset.box);
          const boxes = state.rows[rowIndex].boxes;
          const clone = { ...boxes[boxIndex] };
          boxes.splice(boxIndex + 1, 0, clone);
          renderAll();
          debounceSave();
        });
      });

      document.querySelectorAll("[data-action='box-delete']").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rowIndex = Number(btn.dataset.row);
          const boxIndex = Number(btn.dataset.box);
          state.rows[rowIndex].boxes.splice(boxIndex, 1);
          renderAll();
          debounceSave();
        });
      });
    }

    function applyCanvasHeight() {
      const container = document.getElementById("canvasContainer");
      container.style.height = `${state.settings.canvasHeightPx}px`;
    }

    function getCanvasWidth() {
      const container = document.getElementById("canvasContainer");
      return Number.isFinite(state.settings.canvasWidthPx) && state.settings.canvasWidthPx > 0
        ? state.settings.canvasWidthPx
        : container.clientWidth || 800;
    }

    function computeBoxLayout(settingsOverride = {}) {
      const settings = { ...state.settings, ...settingsOverride };
      const width = getCanvasWidth();
      const {
        spacingPx,
        rowGapPx,
        paddingPx,
        textSizePx,
        heightFactor,
        heightScalePxPerUnit
      } = settings;

      const rows = state.rows.map((row) => {
        const boxes = row.boxes.map((box) => {
          const widthUnits = box.width_value;
          const heightUnits = box.height_value * heightFactor;
          return {
            ...box,
            widthUnits: Number.isFinite(widthUnits) ? widthUnits : 0,
            heightUnits: Number.isFinite(heightUnits) ? heightUnits : 0
          };
        });
        return { ...row, boxes };
      });

      const rowUnitsList = rows.map((row) => row.boxes.reduce((sum, box) => sum + Math.max(0, box.widthUnits), 0));
      const maxRowUnits = rowUnitsList.length ? Math.max(...rowUnitsList) : 0;
      const maxRowBoxCount = rows.reduce((max, row, idx) => {
        if (rowUnitsList[idx] === maxRowUnits) {
          return Math.max(max, row.boxes.length);
        }
        return max;
      }, 1);

      const availableWidthPx = Math.max(0, width - 2 * paddingPx);
      let scaleX = 0;
      if (maxRowUnits > 0) {
        const spacingTotal = spacingPx * Math.max(0, maxRowBoxCount - 1);
        scaleX = (availableWidthPx - spacingTotal) / maxRowUnits;
        if (!Number.isFinite(scaleX) || scaleX < 0) scaleX = 0;
      }

      let yCursor = paddingPx;
      const boxes = [];

      rows.forEach((row) => {
        const rowMaxHeightPx = row.boxes.length
          ? Math.max(...row.boxes.map((box) => Math.max(0, box.heightUnits * heightScalePxPerUnit)))
          : 0;
        const rowCenterY = yCursor + rowMaxHeightPx / 2;
        let xCursor = paddingPx;
        row.boxes.forEach((box) => {
          const widthPx = Math.max(0, box.widthUnits * scaleX);
          const heightPx = Math.max(0, box.heightUnits * heightScalePxPerUnit);
          const fill = legendColor(box.legend_key);
          const textColor = autoTextColor(fill);
          const y = rowCenterY - heightPx / 2;
          const rawText = String(box.text ?? "");
          const lines = rawText.split(/\r?\n/);
          const hasText = lines.some((line) => line.length > 0);
          let fontSize = null;
          if (hasText && widthPx > 0 && heightPx > 0) {
            const maxChars = Math.max(...lines.map((line) => line.length));
            const lineCount = Math.max(1, lines.length);
            const maxFontSize = Math.max(1, box.textSizePx ?? textSizePx ?? 11);
            const widthLimitedSize = maxChars > 0 ? widthPx / (maxChars * 0.6) : maxFontSize;
            const heightLimitedSize = heightPx / (lineCount * 1.2);
            fontSize = Math.max(1, Math.min(maxFontSize, widthLimitedSize, heightLimitedSize));
          }

          boxes.push({
            x: xCursor,
            y,
            width: widthPx,
            height: heightPx,
            fill,
            textColor,
            text: rawText,
            lines,
            hasText,
            fontSize
          });

          xCursor += widthPx + spacingPx;
        });
        yCursor += rowMaxHeightPx + rowGapPx;
      });

      return {
        width,
        rowEndY: yCursor,
        height: Math.max(settings.canvasHeightPx ?? state.settings.canvasHeightPx, yCursor + paddingPx),
        paddingPx,
        boxes
      };
    }

    function renderFigure() {
      const svg = document.getElementById("figureSvg");
      const layout = computeBoxLayout();
      const elements = [];

      layout.boxes.forEach((box) => {
        elements.push(`
          <rect x="${box.x}" y="${box.y}" width="${box.width}" height="${box.height}" rx="0" fill="${box.fill}" stroke="rgba(0,0,0,0.08)" />
        `);

        if (box.hasText && box.width > 0 && box.height > 0 && box.fontSize) {
          const centerX = box.x + box.width / 2;
          const centerY = box.y + box.height / 2;
          const lineHeight = box.fontSize * 1.2;
          const totalTextHeight = box.lines.length * lineHeight;
          const startY = centerY - totalTextHeight / 2 + lineHeight / 2;
          elements.push(`<text x="${centerX}" y="${centerY}" fill="${box.textColor}" font-size="${box.fontSize}" text-anchor="middle" dominant-baseline="middle">`);
          box.lines.forEach((line, index) => {
            const displayLine = line.length ? line : "\u00A0";
            const y = startY + index * lineHeight;
            elements.push(`<tspan x="${centerX}" y="${y}">${escapeHtml(displayLine)}</tspan>`);
          });
          elements.push(`</text>`);
        }
      });

      const legendStartY = layout.rowEndY + 18;
      const legendLayout = layoutLegend(layout.width, layout.paddingPx, legendStartY);
      legendLayout.items.forEach((item) => {
        elements.push(
          `<rect x="${item.x}" y="${item.y}" width="${item.rectWidth}" height="${item.rectHeight}" rx="6" fill="${item.colorHex}" stroke="rgba(0,0,0,0.1)" />`
        );
        elements.push(
          `<text x="${item.x + item.rectWidth / 2}" y="${item.y + item.rectHeight / 2}" fill="${item.textColor}" font-size="${item.fontSize}" text-anchor="middle" dominant-baseline="middle">${escapeHtml(item.label)}</text>`
        );
      });

      const contentHeight = Math.max(state.settings.canvasHeightPx, legendLayout.bottom + layout.paddingPx);
      elements.unshift(`<rect x="0" y="0" width="${layout.width}" height="${contentHeight}" fill="#f7f7f5"></rect>`);
      svg.setAttribute("width", layout.width);
      svg.setAttribute("height", contentHeight);
      svg.setAttribute("viewBox", `0 0 ${layout.width} ${contentHeight}`);
      svg.innerHTML = `
        <style>
          text { font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
        </style>
        ${elements.join("\n")}
      `;
    }

    function layoutLegend(width, paddingPx, startY) {
      const gap = 12;
      const rowGap = 12;
      let x = paddingPx;
      let y = startY;
      const maxX = width - paddingPx;
      const fontSize = Math.max(1, state.settings.legendTextSizePx ?? 12);
      const rectHeight = Math.max(16, fontSize * 1.6);
      const items = [];

      state.legendItems.forEach((item) => {
        const label = item.label || item.key;
        const textWidth = Math.max(40, label.length * fontSize * 0.6);
        const rectWidth = textWidth + 20;
        const textColor = autoTextColor(item.colorHex);

        if (x + rectWidth > maxX) {
          x = paddingPx;
          y += rectHeight + rowGap;
        }

        items.push({
          x,
          y,
          rectWidth,
          rectHeight,
          fontSize,
          label,
          colorHex: item.colorHex,
          textColor
        });

        x += rectWidth + gap;
      });

      return { items, bottom: y + rectHeight };
    }

    function legendColor(key) {
      const item = state.legendItems.find((legend) => legend.key === key);
      return item ? item.colorHex : "#cbd5f5";
    }

    function autoTextColor(hex) {
      const rgb = hexToRgb(hex);
      if (!rgb) return "#111827";
      const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
      return luminance > 0.6 ? "#111827" : "#ffffff";
    }

    function hexToRgb(hex) {
      const normalized = normalizeHex(hex);
      if (!normalized) return null;
      const value = normalized.replace("#", "");
      const r = parseInt(value.substring(0, 2), 16);
      const g = parseInt(value.substring(2, 4), 16);
      const b = parseInt(value.substring(4, 6), 16);
      return { r, g, b };
    }

    function normalizeHex(value) {
      const trimmed = value.trim();
      if (/^#?[0-9a-fA-F]{6}$/.test(trimmed)) {
        return trimmed.startsWith("#") ? trimmed.toLowerCase() : `#${trimmed.toLowerCase()}`;
      }
      return null;
    }

    function colorToPptx(hex) {
      const normalized = normalizeHex(hex);
      if (!normalized) return "111827";
      return normalized.replace("#", "").toUpperCase();
    }

    function exportCsv() {
      const lines = [];
      const settings = state.settings;
      lines.push(`# spacingPx=${settings.spacingPx}`);
      lines.push(`# rowGapPx=${settings.rowGapPx}`);
      lines.push(`# paddingPx=${settings.paddingPx}`);
      lines.push(`# textSizePx=${settings.textSizePx}`);
      lines.push(`# legendTextSizePx=${settings.legendTextSizePx}`);
      lines.push(`# canvasWidthPx=${settings.canvasWidthPx}`);
      lines.push(`# canvasHeightPx=${settings.canvasHeightPx}`);
      lines.push(`# heightFactor=${settings.heightFactor}`);
      lines.push(`# heightScalePxPerUnit=${settings.heightScalePxPerUnit}`);
      state.legendItems.forEach((item) => {
        const colorHex = normalizeHex(item.colorHex) || item.colorHex;
        lines.push(`# legend=${item.key}|${item.label}|${colorHex}`);
      });
      lines.push("row,box,width,height,legend,text");

      state.rows.forEach((row, rowIndex) => {
        const rowValue = row.name?.trim() || `Row ${rowIndex + 1}`;
        row.boxes.forEach((box, boxIndex) => {
          const boxValue = boxIndex + 1;
          const cells = [
            rowValue,
            boxValue,
            box.width_value,
            box.height_value,
            box.legend_key,
            box.text
          ];
          lines.push(cells.map(csvEscape).join(","));
        });
      });

      downloadFile(lines.join("\n"), "box_figure.csv", "text/csv");
    }

    function importCsv(text) {
      const { metadataLines, csvText } = extractMetadata(text);
      const newState = {
        settings: { ...defaultState.settings },
        legendItems: [],
        rows: []
      };

      metadataLines.forEach((line) => {
        const trimmed = line.replace(/^#\s*/, "");
        if (trimmed.startsWith("legend=")) {
          const data = trimmed.replace("legend=", "").split("|");
          if (data.length >= 3) {
            const normalized = normalizeHex(data[2]);
            newState.legendItems.push({
              key: data[0],
              label: data[1],
              colorHex: normalized || defaultPalette[newState.legendItems.length % defaultPalette.length]
            });
          }
        } else {
          const [key, value] = trimmed.split("=");
          if (!key || value === undefined) return;
          if (key in newState.settings) {
            const num = Number(value.trim());
            if (!Number.isNaN(num)) newState.settings[key] = num;
          }
        }
      });

      if (newState.legendItems.length === 0) {
        newState.legendItems = [];
      }

      const rows = parseCSV(csvText);
      if (!rows.length) return;
      const header = rows[0].map((cell) => cell.trim());
      const rowIndex = header.indexOf("row");
      const boxIndex = header.indexOf("box");
      const widthIndex = header.indexOf("width");
      const heightIndex = header.indexOf("height");
      const legendIndex = header.indexOf("legend");
      const textIndex = header.indexOf("text");
      const rowMap = new Map();
      const rowOrder = [];

      rows.slice(1).forEach((cells) => {
        const rawRow = String(cells[rowIndex] ?? "").trim();
        const rowNumber = Number(rawRow);
        const rowName = rawRow
          ? (!Number.isNaN(rowNumber) ? `Row ${rowNumber}` : rawRow)
          : `Row ${rowMap.size + 1}`;
        const boxNumber = Number(cells[boxIndex]);
        if (!rowName || !boxNumber) return;
        if (!rowMap.has(rowName)) {
          rowMap.set(rowName, { name: rowName, boxes: [] });
          rowOrder.push(rowName);
        }
        const row = rowMap.get(rowName);
        row.boxes.push({
          width_value: Number(cells[widthIndex] || 0),
          height_value: Number(cells[heightIndex] || 0),
          legend_key: cells[legendIndex] || "",
          text: cells[textIndex] || ""
        });
      });

      newState.rows = rowOrder.map((key) => rowMap.get(key));

      if (newState.legendItems.length === 0) {
        const keys = new Set();
        newState.rows.forEach((row) => {
          row.boxes.forEach((box) => keys.add(box.legend_key));
        });
        newState.legendItems = Array.from(keys).map((key, index) => ({
          key,
          label: key,
          colorHex: defaultPalette[index % defaultPalette.length]
        }));
      }

      newState.rows.forEach((row) => row.boxes.forEach((box) => ensureLegendKey(box, newState.legendItems)));
      state = normalizeState(newState);
      applyCanvasHeight();
      renderAll();
      debounceSave();
    }

    function extractMetadata(text) {
      const lines = text.split(/\r?\n/);
      const metadataLines = [];
      let startIndex = 0;
      while (startIndex < lines.length) {
        const line = lines[startIndex];
        if (line.trim().startsWith("#")) {
          metadataLines.push(line.trim());
          startIndex += 1;
        } else if (line.trim() === "") {
          startIndex += 1;
        } else {
          break;
        }
      }
      return { metadataLines, csvText: lines.slice(startIndex).join("\n") };
    }

    function parseCSV(text) {
      const rows = [];
      let current = "";
      let row = [];
      let inQuotes = false;
      for (let i = 0; i < text.length; i += 1) {
        const char = text[i];
        const next = text[i + 1];
        if (char === '"') {
          if (inQuotes && next === '"') {
            current += '"';
            i += 1;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === "," && !inQuotes) {
          row.push(current);
          current = "";
        } else if ((char === "\n" || char === "\r") && !inQuotes) {
          if (char === "\r" && next === "\n") i += 1;
          row.push(current);
          if (row.some((cell) => cell !== "")) {
            rows.push(row);
          }
          row = [];
          current = "";
        } else {
          current += char;
        }
      }
      row.push(current);
      if (row.some((cell) => cell !== "")) {
        rows.push(row);
      }
      return rows;
    }

    function csvEscape(value) {
      const stringValue = String(value ?? "");
      if (/[",\n]/.test(stringValue)) {
        return `"${stringValue.replace(/"/g, '""')}"`;
      }
      return stringValue;
    }

    function exportJson() {
      const data = JSON.stringify(state, null, 2);
      downloadFile(data, "box_figure.json", "application/json");
    }

    function exportSvg() {
      const svg = document.getElementById("figureSvg");
      const serialized = serializeSvg(svg);
      downloadFile(serialized, "box_figure.svg", "image/svg+xml;charset=utf-8");
    }

    function exportPng() {
      const svg = document.getElementById("figureSvg");
      const serialized = serializeSvg(svg);
      const svgBlob = new Blob([serialized], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(svgBlob);
      const image = new Image();
      image.onload = () => {
        const scale = 2;
        const canvas = document.createElement("canvas");
        canvas.width = image.width * scale;
        canvas.height = image.height * scale;
        const ctx = canvas.getContext("2d");
        ctx.scale(scale, scale);
        ctx.drawImage(image, 0, 0);
        canvas.toBlob((blob) => {
          if (blob) {
            downloadBlob(blob, "box_figure.png");
          }
          URL.revokeObjectURL(url);
        }, "image/png");
      };
      image.src = url;
    }

    function exportPptx() {
      if (typeof PptxGenJS === "undefined") {
        alert("PPTX export is unavailable.");
        return;
      }

      const layout = computeBoxLayout({ paddingPx: 0, canvasHeightPx: 0 });
      const pptx = new PptxGenJS();
      pptx.layout = "LAYOUT_WIDE";
      const slide = pptx.addSlide();
      const slideWidthIn = 13.333;
      const slideHeightIn = 7.5;
      const marginIn = 0;
      const scaleX = (slideWidthIn - marginIn * 2) / layout.width;
      const scaleY = (slideHeightIn - marginIn * 2) / layout.height;
      const scale = Math.max(0, Math.min(scaleX, scaleY));

      layout.boxes.forEach((box) => {
        if (box.width <= 0 || box.height <= 0) return;
        const x = marginIn + box.x * scale;
        const y = marginIn + box.y * scale;
        const w = box.width * scale;
        const h = box.height * scale;
        slide.addShape(pptx.ShapeType.rect, {
          x,
          y,
          w,
          h,
          fill: { color: colorToPptx(box.fill) },
          line: { color: "E2E8F0", width: 0.5 }
        });
        if (box.hasText && box.text.trim()) {
          const fontSize = Math.max(1, (box.fontSize ?? state.settings.textSizePx ?? 11) * scale * 72);
          const textValue = String(box.text ?? "").replace(/\r?\n/g, "\n");
          slide.addText(textValue, {
            x,
            y,
            w,
            h,
            fontFace: "Segoe UI",
            fontSize,
            color: colorToPptx(box.textColor),
            align: "center",
            valign: "middle"
          });
        }
      });

      const legendStartY = layout.rowEndY + 18;
      const legendLayout = layoutLegend(layout.width, layout.paddingPx, legendStartY);
      legendLayout.items.forEach((item) => {
        const x = marginIn + item.x * scale;
        const y = marginIn + item.y * scale;
        const rectWidth = item.rectWidth * scale;
        const rectHeight = item.rectHeight * scale;
        slide.addShape(pptx.ShapeType.rect, {
          x,
          y,
          w: rectWidth,
          h: rectHeight,
          fill: { color: colorToPptx(item.colorHex) },
          line: { color: "E2E8F0", width: 0.5 },
          radius: 6
        });
        slide.addText(item.label, {
          x,
          y,
          w: rectWidth,
          h: rectHeight,
          fontFace: "Segoe UI",
          fontSize: Math.max(1, (state.settings.legendTextSizePx ?? 12) * scale * 72),
          color: colorToPptx(item.textColor),
          align: "center",
          valign: "middle"
        });
      });

      pptx.writeFile({ fileName: "box_figure.pptx" });
    }

    function serializeSvg(svg) {
      const clone = svg.cloneNode(true);
      clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      return new XMLSerializer().serializeToString(clone);
    }

    function downloadFile(data, filename, type) {
      const blob = new Blob([data], { type });
      downloadBlob(blob, filename);
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    }

    function escapeHtml(str) {
      return String(str ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    document.getElementById("clearStorageBtn").addEventListener("click", () => {
      localStorage.removeItem(STORAGE_KEY);
      state = structuredClone(defaultState);
      renderAll();
    });

    window.addEventListener("resize", () => {
      renderFigure();
    });

    function renderAll() {
      renderSidebar();
      applyCanvasHeight();
      renderFigure();
    }

    renderAll();
  </script>
</body>
</html>
